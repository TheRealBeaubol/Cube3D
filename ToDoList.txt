
    Basics :

✅ Makefile
❌ Norminette
❌ Valgrind

    Subject :

✅ Window management : Change Window / Minimize / Pressing ESC or clicking on red cross to close the window
❌ Display a different wall texture that vary depending on which side the wall is facing (North, South, East, West)
❌ Your program must be able to set the floor and ceiling colors to two different ones
✅ The program displays the image in a window and respects the following rules:
       ❌  The left and right arrow keys of the keyboard must allow you to look left and right in the maze.
       ✅  The W, A, S, and D keys must allow you to move the point of view through the maze.
✅ Your program must take as a first argument a scene description file with the .cub extension.
       ✅  The map must be composed of only 6 possible characters: 0 for an empty space, 1 for a wall, and N,S,E or W for the player’s start position and spawning orientation.
                This is a simple valid map:
                        111111
                        100101
                        101001
                        1100N1
                        111111
       ❌  The map must be closed/surrounded by walls, if not the program must return an error.
       ❌  Except for the map content, each type of element can be separated by one or more empty line(s).
       ❌  Except for the map content which always has to be the last, each type of element can be set in any order in the file.
       ❌  Except for the map, each type of information from an element can be separated by one or more space(s).
       ❌  The map must be parsed as it looks in the file. Spaces are a valid part of the map and are up to you to handle. You must be able to parse any kind of map, as long as it respects the rules of the map.
❌  Have all of these things in the .cub config file
    ❌  NO ./path_to_the_north_texture
    ❌  SO ./path_to_the_south_texture
    ❌  WE ./path_to_the_west_texture
    ❌  EA ./path_to_the_east_texture
    ❌  Floor colors : F -> R,G,B colors in range [0,255]: 0, 255, 255
    ❌  Ceiling colors : C -> R,G,B colors in range [0,255]: 0, 255, 255
    *map*

        Bonus :

❌  Add collisions
✅  Add a minimap system
❌  Doors which can open and close
❌  Animated sprite
❌  Rotate the point of view with the mouse









    int buffer[HEIGHT][WIDTH]


    Uint32 buffer[screenHeight][screenWidth]; // y-coordinate first because it works per scanline
    std::vector texture[8];
    for(int i = 0; i < 8; i++) texture[i].resize(texWidth * texHeight);

The following calculations are new however, and replace the color chooser of the untextured raycaster.

    //generate some textures
    unsigned long tw, th;
    loadImage(texture[0], tw, th, "pics/eagle.png");
    loadImage(texture[1], tw, th, "pics/redbrick.png");
    loadImage(texture[2], tw, th, "pics/purplestone.png");
    loadImage(texture[3], tw, th, "pics/greystone.png");

The value wallX represents the exact value where the wall was hit, not just the integer coordinates of the wall. This is required to know which x-coordinate of the texture we have to use. This is calculated by 
first calculating the exact x or y coordinate in the world, and then substracting the integer value of the wall off it. Note that even if it's called wallX, it's actually an y-coordinate of the wall if side==1, but 
it's always the x-coordinate of the texture.
Finally, texX is the x-coordinate of the texture, and this is calculated out of wallX.

      //texturing calculations
      int texNum = worldMap[mapX][mapY] - 1; //1 subtracted from it so that texture 0 can be used!
      //calculate value of wallX
      double wallX; //where exactly the wall was hit
      if (side == 0) wallX = posY + perpWallDist * rayDirY;
      else           wallX = posX + perpWallDist * rayDirX;
      wallX -= floor((wallX));
      //x coordinate on the texture
      int texX = int(wallX * double(texWidth));
      if(side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
      if(side == 1 && rayDirY < 0) texX = texWidth - texX - 1;

Now that we know the x-coordinate of the texture, we know that this coordinate will remain the same, because we stay in the same vertical stripe of the screen. Now we need a loop in the y-direction to give each 
pixel of the vertical stripe the correct y-coordinate of the texture, called texY.
The value of texY is calculated by increasing by a precomputed step size (which is possible because this is constant in the vertical stripe) for each pixel. The step size tells how much to increase in the texture 
coordinates (in floating point) for every pixel in vertical screen coordinates. It then needs to cast the floating point value to integer to select the actual texture pixel.
NOTE: a faster integer-only bresenham or DDA algorithm may be possible for this.
NOTE: The stepping being done here is affine texture mapping, which means we can interpolate linearly between two points rather than have to compute a different division for each pixel. This is not perspective correct in general, but for perfectly vertical walls (and also perfectly horizontal floors/ceilings) it is, so we can use it for raycasting.
The color of the pixel to be drawn is then simply gotten from texture[texNum][texX][texY], which is the correct texel of the correct texture.
Like the untextured raycaster, here too we'll make the color value darker if an y-side of the wall was hit, because that looks a little bit better (like there is a sort of lighting).
However, because the color value doesn't exist out of a separate R, G and B value, but these 3 bytes sticked together in a single integer, a not so intuitive calculation is used.
The color is made darker by dividing R, G and B through 2. Dividing a decimal number through 10, can be done by removing the last digit (e.g. 300/10 is 30: the last zero is removed).
Similarly, dividing a binary number through 2, which is what is done here, is the same as removing the last bit. This can be done by bitshifting it to the right with >>1. But, here we're bitshifting a
24-bit integer (actually 32-bit, but the first 8 bits aren't used). Because of this, the last bit of one byte will become the first bit of the next byte, and that screws up the color values! So after the bitshift,
the first bit of every byte has to be set to zero, and that can be done by binary "AND-ing" the value with the binary value 011111110111111101111111, which is 8355711 in decimal. So the result of this is indeed a
darker color.
Finally, the current buffer pixel is set to this color, and we move on to the next y.

            // How much to increase the texture coordinate per screen pixel
      double step = 1.0 * texHeight / lineHeight;
      // Starting texture coordinate
      double texPos = (drawStart - h / 2 + lineHeight / 2) * step;
      for(int y = drawStart; y<drawEnd; y++)
      {
        // Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
        int texY = (int)texPos & (texHeight - 1);
        texPos += step;
        Uint32 color = texture[texNum][texHeight * texY + texX];
        //make color darker for y-sides: R, G and B byte each divided through two with a "shift" and an "and"
        if(side == 1) color = (color >> 1) & 8355711;
        buffer[y][x] = color;
      }
